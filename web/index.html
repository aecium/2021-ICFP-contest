<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Free Tacos ICFP Contest 2021 - Visualization and Submission Tool</title>
		<style type="text/css">
			body { font-family: monospace; }
			textarea { width: 100%; }
			.error li {
				background-color: #a00;
				border: 1px solid #900;
				border-radius: 3px;
				padding: 3px;
				color: #fff;
			}
			.row {
				display: flex;
				flex-direction: row;
				flex-wrap: wrap;
				width: 100%;
			}
			.column {
				display: flex;
				flex-direction: column;
				flex-basis: 100%;
				flex: 1;
			}
			#edges-wrapper {
				max-height: 400px;
				overflow: scroll;
			}
			table, td, th {
				width: auto;
				text-align: left;
			}
			.point-error td {
				background-color: #dcc;
			}
			td.ratio-error {
				color: #d00;
				font-weight: bold;
			}
			td.fail {
				color: #d00;
				font-weight: bold;
			}
			td.success {
				color: #0d0;
				font-weight: bold;
			}
			tr:hover {
				background-color: #cdd;
			} 
			table.horizontal td {
				width: 70%;
			}
			.number-input {
				width: 3em;
			}
		</style>
	</head>
	<body>
		<h1>Free Tacos ICFP Contest 2021 - Visualization and Submission Tool</h1>

		<div>
			<label for="problem-data">Problem</label>
			<textarea id="problem-data">{"hole":[[45,80],[35,95],[5,95],[35,50],[5,5],[35,5],[95,95],[65,95],[55,80]],"epsilon":150000,"figure":{"edges":[[2,5],[5,4],[4,1],[1,0],[0,8],[8,3],[3,7],[7,11],[11,13],[13,12],[12,18],[18,19],[19,14],[14,15],[15,17],[17,16],[16,10],[10,6],[6,2],[8,12],[7,9],[9,3],[8,9],[9,12],[13,9],[9,11],[4,8],[12,14],[5,10],[10,15]],"vertices":[[20,30],[20,40],[30,95],[40,15],[40,35],[40,65],[40,95],[45,5],[45,25],[50,15],[50,70],[55,5],[55,25],[60,15],[60,35],[60,65],[60,95],[70,95],[80,30],[80,40]]}}</textarea>

			<label for="problem-file">Load Problem File</label>
			<input type="file" id="problem-file" name="problem-file" onchange="loadProblemFile()" />
		</div>

		<div>
			<label for="solution-data">Solution</label>
			<textarea id="solution-data">{"vertices": [
				[21, 28], [31, 28], [31, 87], [29, 41], [44, 43], [58, 70],
				[38, 79], [32, 31], [36, 50], [39, 40], [66, 77], [42, 29],
				[46, 49], [49, 38], [39, 57], [69, 66], [41, 70], [39, 60],
				[42, 25], [40, 35]
			]}</textarea>
			<ul id="solution-errors" class="error"></ul>
		</div>

		<div>
			<button id="redraw" onclick="redraw()">Redraw</button>
			<button id="reset" onclick="resetSolution(); redraw();">Reset Solution</button>

			<label for="solution-file">Load Solution File</label>
			<input type="file" id="solution-file" name="solution-file" onchange="loadSolutionFile()" />

			<button id="solution-save" onclick="saveSolution()">Save 1-solution.json</button>
			<a href="#save" id="solution-save-link" download="1-solution.json">_</a>
		</div>

		<div class="row">
			<div class="column">
				<table class="horizontal">
					<tr><th>Vertex Status:</th><td id="vertex-status"></td></tr>
					<tr><th>Epsilon Status:</th><td id="epsilon-status"></td></tr>
					<tr><th>Epsilon:</th><td id="epsilon"></td></tr>
					<tr><th>Max Ratio:</th><td id="max-ratio"></td></tr>
					<tr><th>Possible Points:</th><td id="possible-points"></td></tr>
					<tr><th>Dislikes:</th><td id="dislikes"></td></tr>
				</table>

				<h2>Edges:</h2>
				<div id="edges-wrapper">
					<table id="edges-table">
						<thead>
							<tr>
								<th></th>
								<th>In</th>
								<th>X1</th>
								<th>Y1</th>
								<th>X2</th>
								<th>Y2</th>
								<th>Old Length²</th>
								<th>New Length²</th>
								<th>Ratio</th>
							</tr>
						</thead>
						<tbody id="epsilon-table-body">

						</tbody>
					</table>
				</div>
				<ul id="epsilon"></ul>
			</div>
			<div class="column">
				<svg id="vis" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0.0 0.0 100.0 100.0">
					<path id="hole" d="M 45.0,80.0 L 35.0,95.0 L 5.0,95.0 L 35.0,50.0 L 5.0,5.0 L 35.0,5.0 L 95.0,95.0 L 65.0,95.0 L 55.0,80.0 Z M 0.0,0.0 L 100.0,0.0 L 100.0,100.0 L 0.0,100.0" style="fill:#00000066;fill-rule:evenodd;stroke:none;" />
					<g id="figure" style="fill:none;stroke:#aaaaff44;stroke-linecap:round" transform="translate(0.0, 0.0)">
						<path d="M 30.0,95.0 L 40.0,65.0" />
						<path d="M 40.0,65.0 L 40.0,35.0" />
						<path d="M 40.0,35.0 L 20.0,40.0" />
						<path d="M 20.0,40.0 L 20.0,30.0" />
						<path d="M 20.0,30.0 L 45.0,25.0" />
						<path d="M 45.0,25.0 L 40.0,15.0" />
						<path d="M 40.0,15.0 L 45.0,5.0" />
						<path d="M 45.0,5.0 L 55.0,5.0" />
						<path d="M 55.0,5.0 L 60.0,15.0" />
						<path d="M 60.0,15.0 L 55.0,25.0" />
						<path d="M 55.0,25.0 L 80.0,30.0" />
						<path d="M 80.0,30.0 L 80.0,40.0" />
						<path d="M 80.0,40.0 L 60.0,35.0" />
						<path d="M 60.0,35.0 L 60.0,65.0" />
						<path d="M 60.0,65.0 L 70.0,95.0" />
						<path d="M 70.0,95.0 L 60.0,95.0" />
						<path d="M 60.0,95.0 L 50.0,70.0" />
						<path d="M 50.0,70.0 L 40.0,95.0" />
						<path d="M 40.0,95.0 L 30.0,95.0" />
						<path d="M 45.0,25.0 L 55.0,25.0" />
						<path d="M 45.0,5.0 L 50.0,15.0" />
						<path d="M 50.0,15.0 L 40.0,15.0" />
						<path d="M 45.0,25.0 L 50.0,15.0" />
						<path d="M 50.0,15.0 L 55.0,25.0" />
						<path d="M 60.0,15.0 L 50.0,15.0" />
						<path d="M 50.0,15.0 L 55.0,5.0" />
						<path d="M 40.0,35.0 L 45.0,25.0" />
						<path d="M 55.0,25.0 L 60.0,35.0" />
						<path d="M 40.0,65.0 L 50.0,70.0" />
						<path d="M 50.0,70.0 L 60.0,65.0" />
					</g>
					<g id="solution" style="fill:none;stroke:#00ff0088;stroke-linecap:round" transform="translate(0.0, 0.0)">
						<path d="M 10.0,85.0 L 30.0,55.0" />
						<path d="M 30.0,55.0 L 30.0,25.0" />
					</g>
					<g id="error-paths" style="fill:none;stroke:#ff000088;stroke-linecap:round" transform="translate(0.0, 0.0)">
					</g>
					<g id="hilight-paths" style="fill:none;stroke:#ff00ffff;stroke-linecap:round" transform="translate(0.0, 0.0)">
					</g>
				</svg>
			</div>
		</div>

<script>
	function pathToHole(points) {
		let hole = '';
		let op = 'M ';
		let bounds = getBounds(points);
		let x1 = bounds[0][0]-5;
		let y1 = bounds[0][1]-5;
		let x2 = bounds[1][0]+5;
		let y2 = bounds[1][1]+5;

		for(const point of points){
			hole += op + point[0] + "," + point[1];
			op = ' L ';
		}
		return hole + ' Z M '+x1+','+y1+' L '+x2+','+y1+' L '+x2+','+y2+' L '+x1+','+y2;
	}

	function setElementPaths(element, edges, vertices) {
		while(element.firstChild) {
			element.removeChild(element.firstChild);
		}

		for(const edge of edges){
			let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			let p1 = vertices[edge[0]]
			let p2 = vertices[edge[1]];
			path.setAttribute('d', 'M ' + p1[0] + ',' + p1[1] + ' L ' + p2[0] + ',' + p2[1]);
			element.appendChild(path);
		}
	}

	function parseSolutionData(problemData, solutionString) {
		let solutionData = {}
		let errorList = document.getElementById('solution-errors');
		while(errorList.firstChild) {
			errorList.removeChild(errorList.firstChild);
		}

		try {
			solutionData = JSON.parse(solutionString);
		} catch (error) {
			console.error("Could not parse solution.");
			console.error(error);
			let li = document.createElement('li');
			li.textContent = "" + error;
			errorList.appendChild(li);
			throw error;
		}
		return solutionData;
	}

	function resetSolution() {
		let problemData = JSON.parse(document.getElementById('problem-data').value);
		document.getElementById('solution-data').value = JSON.stringify({"vertices":problemData.figure.vertices});
	}

	function squaredDistance(p, q) {
		return ((p[0] - q[0]) ** 2) + ((p[1] - q[1]) ** 2);
	}

	function calculateRatio(oldEdge, newEdge) {
		return Math.abs((squaredDistance(newEdge[0], newEdge[1]) / squaredDistance(oldEdge[0], oldEdge[1])) - 1);
	}

	function possiblePoints(numVertices, numEdges, numHoleVertices){
		return Math.round(1000 * Math.log2(numVertices, numEdges, numHoleVertices));
	}

	function calculateDislikes(hole, vertices){
		let dislikes = 0;
		for(const hv of hole) {
			let min = Number.MAX_SAFE_INTEGER;
			for(const v of vertices) {
				let d = squaredDistance(hv, v);
				if(d < min){
					min = d;
				}
			}
			dislikes += min;
		}
		return Math.round(dislikes);
	}

	function pointInside(point, vertices) {
		let x = point[0];
		let y = point[1];
		let crossings = 0;

		// Odd number of crossings is inside
		let j = vertices.length - 1;
		for (var i = 0; i < vertices.length; i++) {
			let xi = vertices[i][0];
			let yi = vertices[i][1];
			let xj = vertices[j][0];
			let yj = vertices[j][1];
			
			if(((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)){
				crossings += 1;
			}
			j = i;
		}

		return (crossings%2)==1;
	};

	function hilightLine(i){
		edge = problemData.figure.edges[i];
		
		let g = document.getElementById('hilight-paths');
		while(g.firstChild) {
			g.removeChild(g.firstChild);
		}
		p1 = solutionData.vertices[edge[0]];
		p2 = solutionData.vertices[edge[1]];
		
		let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		path.setAttribute('d', 'M ' + p1[0] + ',' + p1[1] + ' L ' + p2[0] + ',' + p2[1]);
		g.appendChild(path);
	}

	function updateSolution(id){
		let input = document.getElementById(id);
		let i = input.dataset.i;
		let vertex = input.dataset.vertex;
		let coord = input.dataset.coord;
		let edge = problemData.figure.edges[i]
		solutionData.vertices[edge[vertex]][coord] = parseInt(input.value);
		document.getElementById('solution-data').value = JSON.stringify(solutionData);
		redraw();
	}

	function createPointInput(i, vertex, coord, value){
		let name = 'point-'+i+'-'+vertex+'-'+coord;
		let input = document.createElement('input');
		input.id = name;
		input.setAttribute('type', 'number');
		input.onfocus = function(e){hilightLine(i);};
		input.onchange = function(e){updateSolution(name);};
		input.dataset.i = i;
		input.dataset.vertex = vertex;
		input.dataset.coord = coord;
		input.name = name;
		input.value = value;
		input.size = 3;
		input.classList.add('number-input');
		return input;
	}

	function populateEpsilonTable(table, epsilon, edges, oldVertices, vertices, hole) {
		let maxRatio = epsilon/1000000;
		let vertexStatus = true;
		let epsilonStatus = true;

		while(table.firstChild) {
			table.removeChild(table.firstChild);
		}

		let errorPaths = document.getElementById('error-paths');
		while(errorPaths.firstChild) {
			errorPaths.removeChild(errorPaths.firstChild);
		}

		document.getElementById('epsilon').textContent = epsilon;
		document.getElementById('max-ratio').textContent = maxRatio;
		document.getElementById('possible-points').textContent = possiblePoints(vertices.length, edges.length, hole.length);
		document.getElementById('dislikes').textContent = calculateDislikes(hole, vertices);

		let i=0;
		for(const edge of edges){
			let p1 = vertices[edge[0]]
			let p2 = vertices[edge[1]];
			let oldP1 = oldVertices[edge[0]]
			let oldP2 = oldVertices[edge[1]];
			let newLength = squaredDistance(p1, p2);
			let oldLength = squaredDistance(oldP1, oldP2);
			let ratio = calculateRatio([oldP1, oldP2], [p1, p2]);
			let isInside = pointInside(p1, hole) && pointInside(p2, hole);

			let tr = document.createElement('tr');
			if(!isInside || ratio > maxRatio){
				if(!isInside){
					vertexStatus = false;
				}
				if(ratio > maxRatio){
					epsilonStatus = false;
				}
				tr.classList.add('point-error');

				let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				path.setAttribute('d', 'M ' + p1[0] + ',' + p1[1] + ' L ' + p2[0] + ',' + p2[1]);
				errorPaths.appendChild(path);
			}

			let td = document.createElement('td');
			td.textContent = i;
			tr.appendChild(td);

			td = document.createElement('td');
			td.textContent = isInside ? '🟢' : '❌';
			tr.appendChild(td);
			tr.add

			td = document.createElement('td');
			td.appendChild(createPointInput(i, 0, 0, p1[0]));
			tr.appendChild(td);

			td = document.createElement('td');
			td.appendChild(createPointInput(i, 0, 1, p1[1]));
			tr.appendChild(td);

			td = document.createElement('td');
			td.appendChild(createPointInput(i, 1, 0, p2[0]));
			tr.appendChild(td);

			td = document.createElement('td');
			td.appendChild(createPointInput(i, 1, 1, p2[1]));
			tr.appendChild(td);

			td = document.createElement('td');
			td.textContent = oldLength;
			tr.appendChild(td);

			td = document.createElement('td');
			td.textContent = newLength;
			tr.appendChild(td);

			td = document.createElement('td');
			td.textContent = ratio.toFixed(5);
			if(ratio>maxRatio){
				td.classList.add('ratio-error');
			}
			tr.appendChild(td);

			table.appendChild(tr);
			i++;
		}

		let el = document.getElementById('vertex-status');
		if(vertexStatus){
			el.textContent = 'PASS';
			el.classList.remove('fail');
			el.classList.add('success');
		} else {
			el.textContent = 'FAIL';
			el.classList.remove('success');
			el.classList.add('fail');
		}

		el = document.getElementById('epsilon-status');
		if(epsilonStatus){
			el.textContent = 'PASS';
			el.classList.remove('fail');
			el.classList.add('success');
		} else {
			el.textContent = 'FAIL';
			el.classList.remove('success');
			el.classList.add('fail');
		}

	}

	function getBounds(points) {
		let minX = Number.MAX_SAFE_INTEGER;
		let minY = Number.MAX_SAFE_INTEGER;
		let maxX = 0;
		let maxY = 0;

		for(const point of points) {
			minX = Math.min(minX, point[0]);
			minY = Math.min(minY, point[1]);
			maxX = Math.max(maxX, point[0]);
			maxY = Math.max(maxY, point[1]);
		}
		return [[minX, minY],[maxX, maxY]];
	}

	let problemData = {};
	let solutionData = {};
	function redraw() {
		let svg = document.getElementById('vis');
		let hole = document.getElementById('hole');
		let figure = document.getElementById('figure');
		let solution = document.getElementById('solution');
		problemData = JSON.parse(document.getElementById('problem-data').value);

		let bounds = getBounds(problemData.hole);
		let x1 = bounds[0][0]-5;
		let y1 = bounds[0][1]-5;
		let x2 = bounds[1][0]+10;
		let y2 = bounds[1][1]+10;
		svg.setAttributeNS(null, 'viewBox', '' + x1 + ' ' + y1 + ' ' + x2 + ' ' + y2);

		hole.setAttribute('d', pathToHole(problemData.hole));
		setElementPaths(figure, problemData.figure.edges, problemData.figure.vertices);

		try {
			solutionData = parseSolutionData(problemData, document.getElementById('solution-data').value);
			setElementPaths(solution, problemData.figure.edges, solutionData.vertices);
		} catch(error) {
			return;
		}

		populateEpsilonTable(document.getElementById('epsilon-table-body'), problemData.epsilon, problemData.figure.edges, problemData.figure.vertices, solutionData.vertices, problemData.hole);
	}

	function loadProblemFile(){
		let file = document.getElementById('problem-file').files[0];
		let reader = new FileReader();
		let solutionName = file.name.replace('.json', '-solution.json');
		document.getElementById('solution-save-link').setAttribute('download', solutionName);
		document.getElementById('solution-save').textContent = 'Save ' + solutionName;
		reader.onload = function(e) {
			document.getElementById('problem-data').value = e.target.result;
			redraw();
		}
		reader.readAsText(file);
	}

	function loadSolutionFile(){
		let file = document.getElementById('solution-file').files[0];
		console.log(file);

		let reader = new FileReader();
		reader.onload = function(e) {
			document.getElementById('solution-data').value = e.target.result;
			redraw();
		}
		reader.readAsText(file);
	}

	var saveFile = null;
	function saveSolution(){
		var data = new Blob([document.getElementById('solution-data').value], {type: 'text/json'});
		if(saveFile !== null) {
			window.URL.revokeObjectURL(saveFile);
		}
		saveFile = window.URL.createObjectURL(data);

		var link = document.getElementById('solution-save-link');
		link.href = saveFile;

		link.dispatchEvent(new MouseEvent('click'));
	}

	redraw();
</script>

	</body>
</html>